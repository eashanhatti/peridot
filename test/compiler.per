axiom CType: MetaType
axiom Int: CType

axiom CTerm: Function(CType) ~> MetaType
axiom zero: CTerm(Int)
axiom one: CTerm(Int)
axiom add: Function(CTerm(Int), CTerm(Int)) ~> CTerm(Int)
axiom var: Function(Text) ~> CTerm(Int)

axiom CStmt: MetaType
axiom return: Function(CTerm(Int)) ~> CStmt

axiom CDecl: MetaType
axiom fun: Function(CType, Text, CType, CStmt) ~> CDecl

axiom CompileTerm: Function(inferred A: CType, CTerm(A), Text) ~> MetaType
axiom compile_add:
  Forall(e1: CTerm(Int), e2: CTerm(Int), t1: Text, t2: Text),
  Implies(
    CompileTerm(e1, t1),
    Implies(
      CompileTerm(e2, t2),
      CompileTerm(add(e1, e2), "(" ++ t1 ++ " + " ++ t2 ++ ")")))
axiom compile_zero: CompileTerm(zero, "0")
axiom compile_one: CompileTerm(one, "1")
axiom compile_var: Forall(t: Text), CompileTerm(var(t), t)

axiom CompileDecl: Function(CDecl, Text) ~> MetaType
axiom compile_fun:
  Forall(x: Text, inTy: CType, cInTy: Text, outTy: CType, cOutTy: Text, body: CStmt, cBody: Text),
  Implies(
    CompileType(inTy, cInTy),
    Implies(
      CompileType(outTy, cOutTy),
      Implies(
        CompileStmt(body, cBody),
        CompileDecl(fun(inTy, x, outTy, body), cOutTy ++ " f(" ++ cInTy ++ " " ++ x ++ ") { " ++ cBody ++ " }"))))

axiom CompileType: Function(CType, Text) ~> MetaType
axiom compile_int: CompileType(Int, "int")

axiom CompileStmt: Function(CStmt, Text) ~> MetaType
axiom compile_return:
  Forall(x: CTerm(Int), t: Text),
  Implies(
    CompileTerm(x, t),
    CompileStmt(return(x), "return " ++ t ++ ";"))

variable t: Text
proof CompileDecl(fun(Int, "x", Int, return(add(one, var("x")))), t)
#output OUTPUT.c t
